# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"
ZSH_CUSTOM="$HOME/rdrive/configs/oh-my-zsh-custom-plugins"

# zsh theme
ZSH_THEME="agnoster"

HISTORY_START_WITH_GLOBAL=true
HISTORY_BASE="$HOME/rdrive/configs/zsh-per-directory-history"
HISTFILE="$HOME/rdrive/configs/.zsh_history"
HISTSIZE=100000000
SAVEHIST=100000000
setopt EXTENDED_HISTORY
setopt INC_APPEND_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_SAVE_NO_DUPS
setopt HIST_FIND_NO_DUPS

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git fast-syntax-highlighting zsh-autosuggestions zsh-fzf-history-search per-directory-history kube-ps1)

# zsh configurations
source $ZSH/oh-my-zsh.sh

# add binaries to path
export PATH=$PATH:$HOME/.cargo/bin
export PATH=~/.npm-global/bin:$PATH
# configure git to use the auto generated commit message
export GIT_MERGE_AUTOEDIT=no

export LS_COLORS="$(vivid generate molokai)"

###### ALIASES ######
# git related aliases
alias g='git'
alias lg='lazygit'
alias gc='git commit -m'
alias gcl='git clone'
alias gs='git status'
alias gsv='git status -v'
alias gm='git merge'
alias gd='git diff'
alias gco='git checkout'
alias gcob='git checkout -b'
alias g-current-branch='git rev-parse --abbrev-ref HEAD'
alias gpo='git push origin'
alias gpoc='git push origin $(g-current-branch)' # Push the current branch to the remote "origin"
alias gplo='git pull origin'
alias gploc='git pull origin $(g-current-branch)'
alias gstsh='git stash'
alias gpop='git stash pop'
alias gdeepclean='git clean -fdx'
alias ghpr='gh pr view --web' # Open current branch's PR on github
alias ghprc='gh pr create'
alias ghprcf='gh pr create -f'
alias gresh='git reset --hard'
alias gupdate='git checkout main && git pull origin main && git checkout - && git merge main'
alias gsubupdate='git submodule update --init --recursive'
alias gbranches='git branch --sort=-committerdate'

unalias ghprcfcmt 2>/dev/null || true
unset -f ghprcfcmt 2>/dev/null || true
ghprcfcmt() {
	PR_OUTPUT=$(gh pr create -f 2>&1)
	PR_URL=$(echo "$PR_OUTPUT" | grep -oE 'https://github.com/[^ ]+/pull/[0-9]+')
	PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

	if [ -z "$PR_URL" ]; then
		PR_URL=$(gh pr view --json url --jq '.url' 2>/dev/null)
	fi
	if [ -z "$PR_NUMBER" ]; then
		PR_NUMBER=$(gh pr view --json number --jq '.number' 2>/dev/null)
	fi

	echo "üöÄ PR created or found: ${PR_URL:-<none>}"
	echo "üî¢ Pull request number: ${PR_NUMBER:+#$PR_NUMBER}"

	if [ -n "$PR_NUMBER" ]; then
		ghprcomment "$PR_NUMBER"
	else
		echo "‚ö†Ô∏è Could not determine PR number; skipping comment."
		echo "‚úÖ Done."
	fi
}

unalias ghprcomment 2>/dev/null || true
unset -f ghprcomment 2>/dev/null || true
ghprcomment() {
	local pr_input="$1"
	local pr_number="$pr_input"

	if [ -z "$pr_number" ]; then
		pr_number=$(gh pr view --json number --jq '.number' 2>/dev/null)
	fi

	if [ -z "$pr_number" ]; then
		echo "‚ö†Ô∏è Could not determine PR number. Provide one explicitly, e.g., 'ghprcomment 123'."
		return 1
	fi

	echo "üî¢ Target PR: #$pr_number"
	gh issue comment "$pr_number" --body '@claude please review this PR. Focus deeply on only two things - 1st - things that can break production and 2nd - any todos that might have gotten left behind'
	echo "üí¨ Comment posted asking @claude to review."
	echo "‚úÖ Done."
}

gundo() {
	git reset HEAD~$1
}

# ffmpeg
alias ffmpeg='ffmpeg -hide_banner'
alias ffprobe='ffprobe -hide_banner'

# aliases for folder shortcuts
alias pro="cd ~/projects"
alias dotfiles="cd ~/dotfiles && code ."

# other aliases
alias weather='curl v2.wttr.in' # print weather for current location (https://github.com/chubin/wttr.in)
alias grep='grep --color=auto'  # colorize `grep` output
alias cat='bat'
alias top='btm'
alias ls='ls --color=auto' # colorize `ls` output
alias l='ls -lhat'
alias ll='l'
alias cls='clear'
alias refreshzsh='source ~/.zshrc'
alias findbyport='netstat -vanp tcp | grep '
alias realtime='while true; do printf "%s\r" "$(date)"; done'
alias realtimeutc='while true; do printf "%s\r" "$(date -u)"; done'
alias checkip="curl ipinfo.io/ip"
alias getuptimer="while true; do osascript -e 'display notification \"time for a 5 minute break\" with title \"30 minutes\" sound name \"nyc_bing_bong_cleaned\"'; sleep 1800; done;"

# elixir / phoenix
## prints pid of phoenix beam processes with their `-name`
alias psbeam='ps aux | grep beam | grep "\-name" | awk '\''{for(i=1;i<=NF;i++) if($i=="-name") print $2, $(i+1)}'\'''

# ai
alias code='cursor'
alias llm='llm -t default'
alias ccc='claude --dangerously-skip-permissions'

# kubectl aliases
alias kc='kubectl'
alias kcg='kubectl get'
alias kcgpo='kubectl get pods'
alias kcpo='kubectl port-forward'
alias kcd='kubectl describe'
alias kcdel='kubectl delete'
alias kcl='kubectl logs'
alias kce='kubectl exec'
alias kcga='kubectl get --all-namespaces'
alias kcapply='kubectl apply -f'
KUBE_PS1_CLUSTER_FUNCTION=cluster_name
function cluster_name() {
	local cluster_name=$(kubectl config current-context)
	if [[ $cluster_name =~ [Pp][Rr][Oo][Dd] ]]; then
		echo "PROD"
	else
		echo "$cluster_name"
	fi
}
RPROMPT='$(kube_ps1)'

execkube() {
	echo getting pod name for $1
	pod_name=$(kubectl get pods -n $1 -o=name | head -n 1)
	echo got $pod_name, running exec bash
	kubectl exec -ti $pod_name -n $1 -- bash
}

klogs() {
	kubectl logs -f -l app=$1 -n $1 --max-log-requests 200
}

for file in $HOME/dotfiles/shell/{private_shell_aliases,private_shell_functions}; do
	[ -r "$file" ] && [ -f "$file" ] && source "$file"
done

ulimit -n 20000

# just completion for zsh
# See: https://just.systems/man/en/shell-completion-scripts.html
if command -v just >/dev/null 2>&1; then
	autoload -Uz compinit && compinit
	eval "$(just --completions zsh)"
fi

# for direnv to hook into zsh. must be at the end of the file
eval "$(direnv hook zsh)"

. $HOMEBREW_PREFIX/etc/profile.d/z.sh
